# Snakefile for creating decoy file
# 
# Usage:
#     snakemake --config decoy_number=3
# Configuration:
# - All parameters should be defined in `config.yaml`.
# - Input files and directories must be specified in the config file.
# 
# Output:
# - Results will be stored in the directory defined by `output_dir/decoy_number` in config.yaml.
#
# Notes:
# - This workflow requires the following tools: bwa, samtools, awk.
# - Adjust the paths in `config.yaml` according to your setup.

import os
import re

configfile: "config.yaml"
awk = config["awk"]
log: "logs/generatedecoy.log"
output_dir = config['output_dir'].format(decoy_number=config['decoy_number'])

rule all:
    input:
        f"{output_dir}/gentrom.fa",
        f"{output_dir}/decoy.txt"

rule make_outfolder:
    output:
        directory(config["output_dir"])
    shell:
        "mkdir -p {output}"

rule extract_trxn:
    input:
        fasta=config["Paths"]["genomefile"],
        gtf=config["Paths"]["gtffile"]
    output:
        f"{output_dir}/transcripts.fa"
    shell:
        """
        {config[gffread]} -g {input.fasta} {input.gtf} -w {output}
        """

rule extract_exon:
    input:
        config["Paths"]["gtffile"]
    output:
        exon_out=temp(f"{output_dir}/exon_out.bed"),
        exon_sort=f"{output_dir}/exon_sort.bed",
        exon_merge=f"{output_dir}/exon_merge.bed"
    shell:
        """
        {config[gffread]} {input} -T -o- | {config[awk]} '$3 == "exon" {{gsub(/"|;/, "", $12); print $1 "\t" $4 "\t" $5 "\t" $12 "\t" $6 "\t" $7}}' > {output.exon_out}
        {config[bedtools]} sort -i {output.exon_out} > {output.exon_sort}
        {config[bedtools]} merge -i {output.exon_sort} -c 4,5,6 -o collapse,collapse,collapse > {output.exon_merge}
        """

rule extract_intron_genes:
    input:
        exon=f"{output_dir}/exon_merge.bed",
        gtf=config["Paths"]["gtffile"],
        genome=config["Paths"]["chromsize"]
    output:
        genes=f"{output_dir}/genes.bed",
        intronic=f"{output_dir}/intronic.bed",
        intronic_merge=f"{output_dir}/intronic_merge.bed",
        intronic_seq=f"{output_dir}/intronic_found.fa"
    shell:
        """
        {config[awk]} -v OFS='\t' '{{if ($3=="gene" && $12 ~ /protein_coding/) {{gsub(/"|;/, "", $10); print $1,$4,$5,$10,$6,$7}}}}' {input.gtf} | {config[bedtools]} sort -g {input.genome}> {output.genes}
        {config[bedtools]} subtract -a {output.genes} -b {input.exon} -nonamecheck > {output.intronic}
        {config[bedtools]} sort -i {output.intronic} | {config[bedtools]} merge -c 4,5,6 -o collapse,collapse,collapse > {output.intronic_merge}
        {config[bedtools]} getfasta -name -fi {config[Paths][genomefile]} -bed {output.intronic_merge} -fo {output.intronic_seq}
        """

rule mask_genome:
    input:
        fasta=config["Paths"]["genomefile"],
        exon=f"{output_dir}/exon_merge.bed"
    output:
        temp(f"{output_dir}/reference.masked.genome.fa")
    shell:
        """
        {config[bedtools]} maskfasta -fi {input.fasta} -bed {input.exon} -fo {output}
        """

rule mashmap:
    input:
        txp=os.path.join(output_dir, "transcripts.fa"),
        mask_gene=f"{output_dir}/reference.masked.genome.fa"
    output:
        f"{output_dir}/mashmap.out"
    shell:
        """
        {config[mashmap]} -r {input.mask_gene} -q {input.txp} -t {config[Params][threads]} --pi 80 -s 500 -o {output}
        """

rule intergenic_decoy_intervals:
    input:
        mashmap=f"{output_dir}/mashmap.out",
        intergen=f"{output_dir}/intergen.bed",
        genome=config["Paths"]["chromsize"]
    output:
        mashmap_bed=temp(f"{output_dir}/mashmap_out_ori.bed"),
        sorted=f"{output_dir}/mashmap_out.bed",
        filtered=temp(f"{output_dir}/mashmap_intergenic_ori.bed"),
        filtered_n_sorted=f"{output_dir}/mashmap_intergenic.bed",
        merged=f"{output_dir}/mashmap_intergenic_merged.bed"
    shell:
        """
        {config[awk]} -v OFS='\t' '{{print $6,$8,$9,$1,".",$5}}' {input.mashmap} > {output.mashmap_bed}
        {config[bedtools]} sort -i {output.mashmap_bed} -g {input.genome} > {output.sorted}
        {config[bedtools]} intersect -a {output.sorted} -b {input.intergen} > {output.filtered}
        {config[bedtools]} sort -i {output.filtered} -g {input.genome} > {output.filtered_n_sorted}
        {config[bedtools]} merge -i {output.filtered_n_sorted} > {output.merged}
        """

rule extract_sequences:
    input:
        fasta=f"{output_dir}/reference.masked.genome.fa",
        bed=f"{output_dir}/mashmap_intergenic_merged.bed"
    output:
        f"{output_dir}/mashmap_intergenic.fa"
    shell:
        """
        {config[bedtools]} getfasta -fi {input.fasta} -bed {input.bed} -fo {output}
        """

rule concat_decoy:
    input:
        decoy=f"{output_dir}/mashmap_intergenic.fa",
        intron=f"{output_dir}/intronic_found.fa"
    output:
        decoy=f"{output_dir}/decoy.fa",
        intron=f"{output_dir}/intron_chr.fa"
    shell:
        """
        {config[awk]} '{{a=$0; getline;split(a, b, ":");  r[b[1]] = r[b[1]]""$0}} END {{ for (k in r) {{ print k"\\n"r[k] }} }}' {input.decoy} > {output.decoy}
        {config[awk]} '{{a=$0; getline;split(a, b, ":");  r[b[1]] = r[b[1]]""$0}} END {{ for (k in r) {{ print k"_intronic\\n"r[k] }} }}' {input.intron} > {output.intron}
        """

rule make_gentrome:
    input:
        decoy=f"{output_dir}/decoy.fa",
        intron=f"{output_dir}/intron_chr.fa",
        trxn=f"{output_dir}/transcripts.fa"
    output:
        f"{output_dir}/gentrom.fa"
    shell:
        """
        cat {input.trxn} {input.decoy} {input.intron} > {output}
        """

rule extract_decoy_ids:
    input:
        decoy=f"{output_dir}/decoy.fa",
        intron=f"{output_dir}/intron_chr.fa"
    output:
        f"{output_dir}/decoy.txt"
    shell:
        """
        grep -h ">" {input.decoy} {input.intron} | {config[awk]} '{{print substr($1,2); }}' > {output}
        """


rule intergenic:
    input:
        genome=config["Paths"]["chromsize"],
        gene=f"{output_dir}/genes.bed"
    output:
        f"{output_dir}/intergen.bed"
    shell:
        "{config[bedtools]} complement -i {input.gene} -g {input.genome} > {output}"